// https://leetcode.com/problems/minimum-moves-to-equal-array-elements
// 
// Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.
// 
// In one move, you can increment `n - 1` elements of the array by `1`.
// 
// **Example 1:**
// 
// ```
// **Input:** nums = [1,2,3]
// **Output:** 3
// **Explanation:** Only three moves are needed (remember each move increments two elements):
// [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
// ```
// 
// **Example 2:**
// 
// ```
// **Input:** nums = [1,1,1]
// **Output:** 0
// ```
// 
// **Constraints:**
// 
// *   `n == nums.length`
// *   `1 <= nums.length <= 10<sup>5</sup>`
// *   `-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup>`
// *   The answer is guaranteed to fit in a **32-bit** integer.

pub fn min_moves(nums: Vec<i32>) -> i32 {

    }

#[test]
pub fn t1() {
}
